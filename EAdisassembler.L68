00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 11/25/2014 1:05:46 PM

00000000                             1  *-----------------------------------------------------------------
00000000                             2  * Title      :  EA
00000000                             3  * Written by :  Greg Kitzmiller
00000000                             4  * Date       :  11/18/14
00000000                             5  * Description:  EA
00000000                             6  *-----------------------------------------------------------------
00000000  =00006000                  7  starting_address   EQU   $00006000   ; 
00000000  =00007000                  8  save_space   EQU   $7000   ; 
00000000  =000000FF                  9  and_mask_ls_eight   EQU   $00FF    ;
00000000  =0000AE45                 10  testString  EQU  $AE45   ;
00000000  =000000FF                 11  FFFcomp  EQU  $000000FF  ; ending 
00000000  =00000000                 12  comp_zero  EQU  $00000000   ;
00000000  =00007000                 13  saveAddress EQU  $00007000   ;
00000000                            14      
00000000                            15      
00000000                            16      
00001000                            17  START:  ORG    $1000         ; first instruction of program
00001000                            18  
00001000  43F8 6000                 19      lea   starting_address,A1   ;   move starting address into A1
00001004  2F09                      20      move.l   A1,-(SP)   ;   pass address on stack    
00001006                            21  
00001006  4EB9 0000101C             22      JSR   BRA   ;   Jumps to the branch always subroutine
0000100C  325F                      23      movea   (SP)+,A1   ;   grabs the pointer to the string 
0000100E  4FEF 0008                 24      lea   (8,SP),SP    ;  cleans stack 
00001012                            25      
00001012  303C 000E                 26      move   #14,D0   ;   14, display string 
00001016  4E4F                      27      trap   #15   ;   display the string in A1     
00001018                            28      
00001018  4E72 2700                 29      stop    #$2700
0000101C                            30      
0000101C                            31  ******************************************************************
0000101C                            32  * Subroutine: Branch always
0000101C                            33  * By: GKITZ
0000101C                            34  * Description: EA for BRA command - prints the PC offset that imm-
0000101C                            35  * idiately follows the instruction whether 8,16, or 32.    
0000101C                            36  ******************************************************************
00000008=                           37      offset   4+4            
00000008= 00000001                  38  address   dc.l   1 
0000101C                            39      org     *      
0000101C                            40      
0000101C                            41      
0000101C                            42  
0000101C                            43  BRA   
0000101C  4E50 0000                 44        link     A0,#0     ; create stack frame 
00001020  2268 0008                 45        move.l   (address,A0),A1   ;  pop the address from the stack 
00001024  3219                      46        move.w  (A1)+,D1   ; move the word into d1
00001026  0281 000000FF             47        andi.l  #and_mask_ls_eight,D1  ;grab the least significant 8-bits
0000102C  B2BC 00000000             48        cmp.l   #comp_zero,D1   ;if they're all 0's then grab the 16-bit displacement 
00001032                            49  
00001032  6700 0018                 50        beq     SIXTEEN_DISPLACE
00001036  B2BC 000000FF             51        cmp.l   #FFFcomp,D1   ;if they're all F's then grab the 32 displacement
0000103C  6700 000C                 52        beq   THIRTY_TWO_DISPLACE   ;  and store the 32 bit displacement
00001040  6000 002A                 53        bra   EIGHT_DISPLACE   ;otherwise, store the displacement address as hex 
00001044                            54        
00001044                            55  
00001044  4E58                      56        unlk   A0 
00001046  4E75                      57        rts    ;   retun to OP-code   
00001048                            58  *******************************************************************     
00001048                            59  * 
00001048                            60  NOP   * NOP subroutine 
00001048  4E75                      61        RTS   ; literally, no EA is done for NOP - cool 
0000104A                            62  
0000104A                            63  *******************************************************************
0000104A                            64  THIRTY_TWO_DISPLACE          ;grabs the 32-bit displacement
0000104A  4E75                      65     RTS   ;returns to the caller
0000104C                            66  
0000104C                            67  *******************************************************************
0000104C                            68  
0000104C                            69  
0000104C                            70  SIXTEEN_DISPLACE
0000104C  2449                      71      movea.l  A1,A2   ;   save a1
0000104E  43F9 00001070             72      lea   sixteen_offset,A1   ;   loads 'offest' into A1
00001054  103C 000E                 73      move.b   #14,D0   ; print string with no newline 
00001058  4E4F                      74      trap   #15   ;   trap call 
0000105A  224A                      75      movea.l   A2,A1   ; move a2 back to a1
0000105C  4241                      76      clr    D1   ;   clears register for printing offset 
0000105E  3219                      77      move.w   (A1)+,D1   ;   saves offset and increments
00001060  103C 0003                 78      move.b   #3,D0   ;   moves whatever is in D1.L
00001064  4E4F                      79      trap     #15   ;
00001066  2F09                      80      move.l  A1,-(SP)   ;  saves the address on the stack 
00001068  4E58                      81      unlk   A0   ;   unlink A0 
0000106A  4E75                      82      rts   ; return to subroutine 
0000106C                            83  *******************************************************************
0000106C                            84      
0000106C                            85  EIGHT_DISPLACE   
0000106C                            86      
0000106C                            87  *******************************************************************
0000106C                            88  * Subroutine: NEG
0000106C                            89  * Descritpion: 
0000106C                            90  NEG
0000106C                            91  
0000106C                            92  *******************************************************************
0000106C  FFFF FFFF                 93     SIMHALT   ; 
00001070                            94     
00001070= 64697370 6C616365 ...     95  sixteen_offset   dc.l   'displacement (in hex):  ',0   ; message to write out with displacement 
0000108C                            96  
0000108C                            97     END   START   ; 

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDRESS             8
AND_MASK_LS_EIGHT   FF
BRA                 101C
COMP_ZERO           0
EIGHT_DISPLACE      106C
FFFCOMP             FF
NEG                 106C
NOP                 1048
SAVEADDRESS         7000
SAVE_SPACE          7000
SIXTEEN_DISPLACE    104C
SIXTEEN_OFFSET      1070
START               1000
STARTING_ADDRESS    6000
TESTSTRING          AE45
THIRTY_TWO_DISPLACE  104A
